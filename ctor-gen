#!/usr/bin/env perl

die "MORE ARGS" unless @ARGV == 1;
my ($typename) = @ARGV;

unlink("$typename.h");
unlink("$typename.c");

open(SRC, "$typename.ctors") || die $!;

while (<SRC>) {
  my @foo = split(/\s/);
  $ctor = shift(@foo);
  $ctors{$ctor} = \@foo;
}

close(SRC);

open(H, ">$typename.h") || die $!;
open(C, ">$typename.c") || die $!;

print H "#include <stdio.h>\n";
print C "#include \"$typename.h\"\n";
print C "#include \"a.h\"\n";
print C "#include \"mem.h\"\n";

print C "#include \"ctor-support.c\"\n";

print H "#ifndef __${typename}_h_\n";
print H "#define __${typename}_h_\n";

print H "typedef enum {\n";
while (my ($ctor, $args) = each %ctors) {
  print H "  TAG_$ctor,\n";
}
print H "  TAG_DUMMY\n";
print H "} ${typename}_tag;\n";

print H "typedef struct $typename $typename;\n";

print H "struct $typename {\n";
print H "  ${typename}_tag tag;\n";
print H "  union {\n";

while (my ($ctor, $args) = each %ctors) {
  print H "    struct {\n";
  foreach $arg (@$args) {
    my ($type, $name) = split(/:/, $arg);
    print H "       $type $name;\n";
  }
  print H "    } $ctor;\n";
}

print H "  } u;\n";
print H "};\n";

print H "\n";

while (my ($ctor, $args) = each %ctors) {
  print H "#define is$ctor(__poop) ((__poop)->tag == TAG_$ctor)\n";

  my $proto = "";
  $proto .= "$typename* mk$ctor(";
  foreach $arg (@$args) {
    my ($type, $name) = split(/:/, $arg);
    $proto .= "$type $name";
    if ($arg ne $args->[@args - 1]) {
      $proto .= ", ";
    }
  }
  $proto .= ")";

  print H "$proto;\n";

  print C "$proto {\n";
  print C "  $typename* y = NEW($typename);\n";
  print C "  A(y);\n";
  print C "  y->tag = TAG_$ctor;\n";
  foreach $arg (@$args) {
    my ($type, $name) = split(/:/, $arg);
    print C "  y->u.$ctor.$name = $name;\n";
  }
  print C "  return y;\n";
  print C "}\n";
  print C "\n";
}

# TODO: Can't have nested matches, because of single variable __vap.
print H "#define match(e) __${typename}_vap = e; switch(__${typename}_vap->tag) { case TAG_DUMMY:\n";
print H "#define end break; } default: { err((\"asdf\")); }\n";

print H "extern $typename* __${typename}_vap;\n";
print C "$typename* __${typename}_vap;\n";

while (my ($ctor, $args) = each %ctors) {
  $Ctor = ucfirst($ctor);
  print H "#define $Ctor(";
  my @names = ();
  foreach $arg (@$args) {
    my ($type, $name) = split(/:/, $arg);
    push(@names, $name);
  }
  @names = map { "_$_" } @names;
  print H join(", ", @names);
  print H ") break; } case TAG_$ctor: { ";
  foreach $arg (@$args) {
    my ($type, $name) = split(/:/, $arg);
    push(@names, $name);
    print H "$type _$name = __${typename}_vap->u.$ctor.$name; ";
  }
  print H "\n";
}

# serialization
print H "void serialize(FILE* fp, yeah* y);\n";
print C "void serialize(FILE* fp, yeah* y) {\n";
print C "  fprintf(fp, \"%d\\n\", y->tag);\n";
print C "  match (y) {\n";

while (my ($ctor, $args) = each %ctors) {
  my @names = ();
  foreach $arg (@$args) {
    my ($type, $name) = split(/:/, $arg);
    push(@names, $name);
  }

  my $Ctor = ucfirst($ctor);
  print C "    $Ctor(" . join(", ", @names) . ") {\n";

  foreach $arg (@$args) {
    my ($type, $name) = split(/:/, $arg);
    if ($type eq ($typename . "*")) {
      # Recursive call
      print C "      serialize(fp, $name);\n";
    } elsif ($type eq "char*") {
      print C "      fprintf(fp, \"%s\\n\", $name);\n";
    } elsif ($type eq "int") {
      print C "      fprintf(fp, \"%d\\n\", $name);\n";
    } else {
      die;
    }
  }

  print C "    }\n";
}


print C "    end;\n";
print C "  }\n";
print C "}\n";

print C "\n";

# unserialization
print H "yeah* unserialize(FILE* fp);\n";
print C "yeah* unserialize(FILE* fp) {\n";

#print C "  printf(\"GET TAG\\n\");\n";
#print C "  ${typename}_tag tag;\n";
#print C "  A(fscanf(fp, \"%d\", &tag) == 1);\n";
print C "  ${typename}_tag tag = readint(fp);\n";
#print C "  printf(\"GOT TAG %d\\n\", tag);\n";
print C "  switch (tag) {\n";

while (my ($ctor, $args) = each %ctors) {
  my $Ctor = ucfirst($ctor);

  print C "    case TAG_$ctor: {\n";
  #print C "      printf(\"IT IS $ctor (%d)\\n\", tag);\n";

  my @names = ();
  foreach $arg (@$args) {
    my ($type, $name) = split(/:/, $arg);
    push(@names, $name);
  }

  foreach $arg (@$args) {
    my ($type, $name) = split(/:/, $arg);

    my $setter = "";
    if ($type eq "$typename*") {
      $setter = "unserialize(fp)";
    } elsif ($type eq "char*") {
      $setter = "readstring(fp)";
    } elsif ($type eq "int") {
      $setter = "readint(fp)";
    } else {
      die "?? $type";
    }

    print C "      $type $name = $setter;\n";
  }

  print C "      return mk$ctor(" . join(", ", @names) . ");\n";
  print C "      break;\n";
  print C "    }\n";
}

print C "    default: err((\"????????\"));\n";
print C "  }\n";
print C "  err((\"??T?T?T\"));\n";
print C "}\n";

print H "#endif // ifdef __$typename_h_\n";

close(H);
close(C);
