#!/usr/bin/env perl

$|=1;

use strict;

use Data::Dumper;
use File;

my %nodes;
my %abnodes;
my %tnodes = ();
my $dcls;

my @integer_types = ("unsigned", "int");

my $c_header = <<EOF;
#include "a.h"
#include "mem.h"
#include "vor.h"
#include "garf.impl.h"
#include "misc/cg.h"
EOF

sub member($$) {
  my ($e, $list) = @_;
  foreach my $ee (@$list) {
    return 1 if ($e eq $ee);
  }
  return 0;
}

sub psshew
{
  my @things = @_;
  my $s = "";

  foreach my $thing (@things) {
    my $dumped;

    local $Data::Dumper::Terse = 1;
    local $Data::Dumper::Indent = 1;
    #local $Data::Dumper::Maxdepth = 2;
    local $Data::Dumper::Sortkeys = 1;

    $dumped = +Dumper( $thing );
    $dumped =~ s/\n$//;

    $s .= "$dumped\n";
  }
  return $s;
}

sub nshew {
  my ($depth, $thing) = @_;
  my $s = "";

  my $dumped;

  local $Data::Dumper::Terse = 1;
  local $Data::Dumper::Indent = 1;
  local $Data::Dumper::Maxdepth = $depth;
  local $Data::Dumper::Sortkeys = 1;

  $dumped = +Dumper( $thing );
  $dumped =~ s/\n$//;

  $s .= "$dumped\n";
  print $s;
}

sub shew( @ )
{
  foreach (@_) {
    print psshew($_);
  }
}

sub zip($$) {
  my ($a, $b) = @_;
  die (@$a . "!=" . @$b) unless (@$a == @$b);
  my @z = ();
  for (my $i = 0; $i < @$a; ++$i) {
    $z[$i] = [ $a->[$i], $b->[$i] ];
  }
  return \@z;
}

sub trim($) {
  my $s = shift;
  $s =~ s/^\s*//;
  $s =~ s/\s*$//;
  return $s;
}

# Turn "unsigned char" to "unsigned_char", e.g., to prevent 'char'
# from seeming like it's in a different column.
sub burp($) {
  my ($s) = @_;
  $s =~ s/unsigned char/unsigned_char/;
  return $s;
}

sub build_tree_1($$) {
  my ($index, $seen) = @_;

  if (defined ($seen->{$index})) {
    return $seen->{$index};
  }

  my $node;
  if (!(defined $abnodes{$index})) {
    return "DANGLING $index";
  }
  my $abnode = $abnodes{$index};
  my $node = {};
  $seen->{$index} = $node;
  while (my ($k, $v) = each %$abnode) {
    if ($v =~ /^\@/ && $k ne "index") {
      $v = build_tree_1($v, $seen);
    }
    $node->{$k} = $v;
  }

  return $node;
}

sub build_tree($) {
  my ($index) = @_;
  return build_tree_1($index, \%tnodes);
}

sub lookup($$) {
  my ($node, $path) = @_;
  my $v = mlookup($node, $path);
  if (!defined($v)) {
    print "==============\n";
    shew($node);
    die "lookup $path" 
  }
  return $v;
}

sub mlookup($$) {
  my ($node, $path) = @_;
  my @path = split(/\//, $path);
  while (@path > 0) {
    my $k = shift(@path);
    if (!defined $node->{$k}) {
      return undef;
    }
    $node = $node->{$k};
  }
  return $node;
}

sub defd($$) {
  my ($node, $path) = @_;
  my @path = split(/\//, $path);
  while (@path > 0) {
    my $k = shift(@path);
    if (!defined($node->{$k})) {
      return 0;
    }
    $node = $node->{$k};
  }
  return 1;
}

my $maxlevel = 5;
my $level = 0;

my $tabb = "| ";

sub dumpit($) {
  return if ($level >= $maxlevel);
  my ($node) = @_;
  if (ref $node eq "ARRAY") {
    print $tabb x $level;
    print "[]\n";
    for (my $i = 0; $i < @$node; ++$i) {
      my $v = $node->[$i];
      if (ref($v) eq "") {
        print $tabb x $level;
        print "$i: $v\n";
      } else {
        print $tabb x $level;
        print "[$i]:\n";
        $level++;
        dumpit($v);
        $level--;
      }
    }
  } elsif (ref $node eq "HASH") {
    print $tabb x $level;
    print "[$node->{nodetype}]\n";
    my @k = keys %$node;
    foreach my $k (keys %$node) {
      my $v = $node->{$k};
      if (ref($v) eq "") {
        print $tabb x $level;
        print "$k: $v\n";
      } else {
        print $tabb x $level;
        print "$k:\n";
        $level++;
        dumpit($v);
        $level--;
      }
    }
  } elsif (ref $node eq "") {
    print "$node\n";
  } else {
    die $node;
  }
}

sub chanwalk($) {
  my ($node) = @_;
  my $here = $node;
  my @rs = ();
  while (1) {
    push @rs, $here;
    if (ref $here eq "HASH" && defined $here->{"chan"}) {
      $here = $here->{"chan"};
    } else {
      last;
    }
  }
  return \@rs; 
}

sub id($) {
  my ($v) = @_;
  return $v;
}

my $unique_serial = 0;
sub unique($) {
  my ($prefix) = @_;
  return $prefix . ($unique_serial++);
}

sub name_undef($$) {
  my ($prefix, $v) = @_;
  if (!defined($v)) {
    return unique($prefix);
  } else {
    return $v;
  }
}

sub getparam($) {
  my ($t) = @_;
  my $stars = "";
  if (lookup($t, "nodetype") eq "pointer_type" &&
      lookup($t, "ptd/nodetype") eq "function_type") {
    return gurt(lookup($t, "ptd"));
  }
  while (!defd($t, "name/name/strg")) {
    defd($t, "ptd") || die;
    $stars .= "*";
    $t = lookup($t, "ptd");
  }
  my $type = lookup($t, "name/name/strg");
  $type .= $stars;
  return $type;
}

sub gurt($) {
  my ($fun) = @_;
  my $stuff = {};
  $stuff->{"name"} = name_undef("anonf", mlookup($fun, "name/strg"));
  #print "NAME $stuff->{name}\n";

  if (defd($fun, 'retn/name/name/strg')) {
    $stuff->{"return_type"} = lookup($fun, 'retn/name/name/strg');
  } else {
    #nshew(3, mlookup($fun, 'retn/name/name/strg'));
    $stuff->{"return_type"} = getparam(lookup($fun, "type/retn"));
  }

  if (defd($fun, "args")) {
    my @paramtypes = map { getparam($_); } (map { lookup($_, "valu"); } @{chanwalk(lookup($fun, "type/prms"))});
    #die $paramtypes[$#paramtypes] unless $paramtypes[$#paramtypes] eq "void";
    #shew("bug", $stuff->{name}, $paramtypes[$#paramtypes]);
    my @paramnames = map { name_undef("anonp", $_) } (map { mlookup($_, "name/strg"); } (@{chanwalk(lookup($fun, "args"))}));

    # Trailing char* for e.g. varargs asprintf; everything else has trailing void
    if ((scalar @paramtypes)-1 == (scalar @paramnames)) {
      @paramtypes = @paramtypes[0..$#paramtypes-1];
    }

    $stuff->{"params"} = zip(\@paramtypes, \@paramnames);
    #nshew(5, \@params);
  } else {
    $stuff->{"params"} = [];
  }

  return $stuff;
}

sub function_decls($) {
  my ($t) = @_;
  my $dcls = chanwalk(lookup($t, "dcls"));
#shew($dcls);
  $dcls = [grep { $_->{"nodetype"} eq "function_decl"; } @$dcls];
  return $dcls;
}

sub funfile($) {
  my ($fun) = @_;
  my $filename = lookup($fun, "srcp");
  $filename =~ s/\:\d+$//;
  return $filename;
}

sub readem() {
  print "READING...\n";
  my @lines = <>;

  my %nodes;
  my $current;
  my $current_id;
  foreach my $line (@lines) {
    chomp($line);

    $line = burp($line);

    if ($line =~ /^(\@\d+)\s+(\S+)/) {
      if ($current_id) {
        $nodes{$current_id} = $current;
      }
      $current_id = $1;
      $current = {};
      $current->{"nodetype"} = $2;
      $current->{"index"} = $current_id;
    } else {
      die if (!defined($current) || !defined($current_id));
    }

    my %stuff;
    foreach my $gark (55, 40, 25) {
      #print "-- $line\n";
      #print "- " . substr($line, $gark - 1) . "\n";
      if (substr($line, ($gark - 1)) =~ /^ \S/) {
        my $bluh = substr($line, $gark);
        if ($bluh =~ /^(\S...): (.*)$/) {
          my $k = $1;
          my $v = $2;
          #print "$k=$v\n";
          $stuff{trim($k)} = trim($v);
        } else {
          $bluh = trim($bluh);
          $stuff{$bluh} = 1;
        }
        $line = substr($line, 0, $gark);
      }
    }

    $current = {%$current, %stuff};
  }
  if ($current_id) {
    $nodes{$current_id} = $current;
  }
  %abnodes = %nodes;
}

sub go() {
  readem();

  print "BUILDING TREE...\n";
  my $tree = build_tree("\@1");

  my @files = ("vertex_and_fragment_program.c", "cg.h", "cgGL.h", "cgGL_profiles.h",
               "cg_bindlocations.h", "cg_datatypes.h", "cg_enums.h", "cg_errors.h",
               "cg_profiles.h", "gl.h", "glext.h", "glu.h", "glut.h");

  $dcls = function_decls($tree);

my @dcls = @$dcls;
@dcls = @dcls[0..4];
$dcls = \@dcls;

  my @funs = ();
  for (my $i = 0; $i < @$dcls; ++$i) {
    my $fun = $dcls->[$i];
    if (member(funfile($fun), \@files)) {
      #shew($i);
      #shew("SRC", lookup($fun, "srcp"));
      #nshew(5, $fun);
      #nshew(4, gurt($fun));
      push(@funs, gurt($fun));
    }
  }

  return \@funs;
}

sub sig($) {
  my ($fun) = @_;
  my $sig = "";

  my $params = join(", ",
                    map { "$_->[0] $_->[1]" } @{$fun->{"params"}});

  $sig .= $fun->{"return_type"};
  $sig .= " ";
  $sig .= $fun->{"name"};
  $sig .= "(";
  $sig .= $params;
  $sig .= ")";

  return $sig;
}

sub opaque_wrap($$) {
  my ($type, $var) = @_;
  if (member($type, \@integer_types)) {
    return "integer($var)";
  } elsif ($type eq "float") {
    return "flote($var)";
  } else {
    return "opaque($var)";
  }
}

sub opaque_unwrap($$) {
  my ($type, $var) = @_;
  if (member($type, \@integer_types)) {
    return "getint($var)";
  } elsif ($type eq "float") {
    return "getfloat($var)";
  } else {
    return "opaqueval($var)";
  }
}

sub gen_cbody($) {
  my ($fun) = @_;
  #print sig($fun);

  my $s = "";

  my $name = $fun->{"name"};
  my $return_type = $fun->{"return_type"};
  my $arg = unique("arg");

  $s .= "yeah* foop_$name(yeah* $arg) {\n";

  my $here = unique("here");
  $s .= "  yeah* $here = $arg;\n";

  my @names = ();
  foreach my $p (@{$fun->{"params"}}) {
    my ($type, $name) = @$p;

    push(@names, $name);

    my $harg = unique("harg");
    $s .= "  yeah* $harg = hcar($here);\n";
    $s .= "  $type $name = " . opaque_unwrap($type, $harg) . ";\n";
    $s .= "  $here = hcdr($here);\n";
  }
  $s .= "  A(isnil($here));\n";

  my $funcall = "$name(" . join(", ", @names) . ")";
  if ($return_type eq "void") {
    $s .= "  $funcall;\n";
    $s .= "  return Nil;\n";
  } else {
    my $ret = unique("ret");
    $s .= "  $return_type $ret = $funcall;\n";
    $s .= "  return " . opaque_wrap($return_type, $ret) . ";\n";
  }
  $s .= "}\n";

  return $s;
}

sub genregisterer($) {
  my ($dcls) = @_;
  my $s = "";
  $s .= "void fakey_impl_register() {\n";
  for (my $i = 0; $i < @$dcls; ++$i) {
    my $fun = $dcls->[$i];
    my $name = $fun->{"name"};
    $s .= "  register_command(\"foop_$name\", &foop_$name);\n";
  }
  $s .= "}\n";
  return $s;
}

my $oot = 
{
  'name' => 'glutInitDisplayMode',
  'params' => [
    [
      'unsigned',
      'mode'
    ]
  ],
  'return_type' => 'void'
};

sub impl_c($) {
  my ($dcls) = @_;
  my $s = "";
  $s .= $c_header;
  for (my $i = 0; $i < @$dcls; ++$i) {
    my $fun = $dcls->[$i];
    $s .= gen_cbody($fun);
  }
  $s .= genregisterer($dcls);
  return $s;
}

#print gen_cbody($oot);

my $funs = go();

sub impl() {
  my $name = "garf";
  my $c = impl_c($funs);
  my $h = "extern void fakey_impl_register();\n";
  File::writeFile("$name.impl.c", $c);
  File::writeFile("$name.impl.h", $h);
}

impl();
