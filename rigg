#!/usr/bin/env perl

$|=1;

use strict;

use Data::Dumper;

sub psshew
{
  my @things = @_;
  my $s = "";

  foreach my $thing (@things) {
    my $dumped;

    local $Data::Dumper::Terse = 1;
    local $Data::Dumper::Indent = 1;

    $dumped = +Dumper( $thing );
    $dumped =~ s/\n$//;

    $s .= "$dumped\n";
  }
  return $s;
}

sub shew( @ )
{
  foreach (@_) {
    print psshew($_);
  }
}


print "READING...\n";
my @lines = <>;

my $all = join('', @lines);
$all =~ s/\n( +)/ /gm;
my @nodelines = split(/\n/, $all);
#shew(\@nodelines);

my %abnodes = ();

print "PARSING...\n";
foreach my $nodeline (@nodelines) {
  my @words = split(/\s+/, $nodeline);
  #print join(":::", @words) . "\n";
  my %node = ();
  $node{"index"} = shift(@words);
  $node{"nodetype"} = shift(@words);
  while (@words > 0) {
    if ($words[0] =~ /:$/) {
      my $k = shift(@words);
      my $v = shift(@words);

      $k =~ s/:$// || die "\"$k\"";

      $node{$k} = $v;
    } else {
      my $k = shift(@words);
      $node{$k} = 1;
    }
  }

  $abnodes{$node{"index"}} = \%node;
}

sub build_tree_1($$) {
  my ($index, $seen) = @_;

  if (defined ($seen->{$index})) {
    return $index;
  } else {
    $seen->{$index} = 1;
  }

  my $node;
  if (!(defined $abnodes{$index})) {
    return "DANGLING";
  }
  my $node = $abnodes{$index};
  my %node = (%$node);
  while (my ($k, $v) = each %node) {
    next if ($k eq "index");
    if ($v =~ /^\@/) {
      $v = build_tree_1($v, $seen);
      $node{$k} = $v;
    }
  }

  return \%node;
}

sub build_tree($) {
  my ($index) = @_;
  return build_tree_1($index, {});
}

sub lookup($$) {
  my ($node, $path) = @_;
  my @path = split(/\//, $path);
  while (@path > 0) {
    my $k = shift(@path);
    die "$node: $path" if (!defined $node->{$k});
    $node = $node->{$k};
  }
  return $node;
}

my $maxlevel = 3;
my $level = 0;

sub dumpit($) {
  return if ($level >= $maxlevel);
  my ($node) = @_;
  if (ref $node eq "ARRAY") {
    foreach my $v (@$node) {
      if (ref($v) eq "") {
        print "  " x $level;
        print "$v\n";
      } else {
        print "  " x $level;
        $level++;
        dumpit($v);
        $level--;
      }
    }
  } elsif (ref $node eq "HASH") {
    print "$node->{nodetype}\n";
    while (my ($k, $v) = each %$node) {
      if (ref($v) eq "") {
        print "  " x $level;
        print "$k: $v\n";
      } else {
        print "  " x $level;
        print "$k:\n";
        $level++;
        dumpit($v);
        $level--;
      }
    }
  } else {
    die $node;
  }
}

print "BUILDING TREE...\n";
#shew(\%abnodes);
my $tree = build_tree("\@1");
#shew($tree);

#shew(lookup($tree, "dcls"));
#dumpit(lookup($tree, "dcls"));
my $dcls = lookup($tree, "dcls");

sub chanmap($$) {
  my ($f, $node) = @_;
  my $here = $node;
  my @rs = ();
  while (1) {
    my $r = $f->($here);
    push @rs, $r;
    if (ref $here eq "HASH" && defined $here->{"chan"}) {
      $here = $here->{"chan"};
    } else {
      last;
    }
  }
  return \@rs; 
}

sub id($) {
  my ($v) = @_;
  return $v;
}

dumpit(chanmap(\&id, $dcls));
