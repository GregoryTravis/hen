#!/usr/bin/env perl

$|=1;

use strict;

use Carp;
use Data::Dumper;

my @integer_types = ("unsigned", "int", "unsigned char", "GLboolean");
my @float_types = ("float", "double", "GLfloat", "GLdouble", "GLclampf", "GLclampd");

my @files = ("butt.c", "vertex_and_fragment_program.c", "gl.h", "glut.h");

my $c_header = <<EOF;
#include "a.h"
#include "mem.h"
#include "vor.h"
#include <glut.h>
#include <GL/gl.h>
#include <GL/glext.h>
#include <cg.h>
#include "vertex_and_fragment_program.h"
EOF

my $extern_c_top = "#ifdef __cplusplus\nextern \"C\" {\n#endif\n";
my $extern_c_bottom = "#ifdef __cplusplus\n}\n#endif\n";

# Write contents of string.
sub writeFile( $$ )
{
  my ($filename,$contents) = @_;
  open( FILE, ">$filename" ) || die "Can't open $filename: $!";
  print FILE $contents;
  close( FILE );
}

sub member($$) {
  my ($e, $list) = @_;
  foreach my $ee (@$list) {
    return 1 if ($e eq $ee);
  }
  return 0;
}

sub psshew
{
  my @things = @_;
  my $s = "";

  foreach my $thing (@things) {
    my $dumped;

    local $Data::Dumper::Terse = 1;
    local $Data::Dumper::Indent = 1;
    #local $Data::Dumper::Maxdepth = 2;
    local $Data::Dumper::Sortkeys = 1;

    $dumped = +Dumper( $thing );
    $dumped =~ s/\n$//;

    $s .= "$dumped\n";
  }
  return $s;
}

sub nshew {
  my ($depth, $thing) = @_;
  my $s = "";

  my $dumped;

  local $Data::Dumper::Terse = 1;
  local $Data::Dumper::Indent = 1;
  local $Data::Dumper::Maxdepth = $depth;
  local $Data::Dumper::Sortkeys = 1;

  $dumped = +Dumper( $thing );
  $dumped =~ s/\n$//;

  $s .= "$dumped\n";
  print $s;
}

sub shew( @ )
{
  foreach (@_) {
    print psshew($_);
  }
}

sub zip($$) {
  my ($a, $b) = @_;
  die (@$a . "!=" . @$b) unless (@$a == @$b);
  my @z = ();
  for (my $i = 0; $i < @$a; ++$i) {
    $z[$i] = [ $a->[$i], $b->[$i] ];
  }
  return \@z;
}

sub trim($) {
  my $s = shift;
  $s =~ s/^\s*//;
  $s =~ s/\s*$//;
  return $s;
}

# Turn "unsigned char" to "unsigned_char", e.g., to prevent 'char'
# from seeming like it's in a different column.
sub burp($) {
  my ($s) = @_;
  $s =~ s/unsigned char/unsigned_char/;
  return $s;
}

sub unburp($) {
  my ($s) = @_;
  $s =~ s/unsigned_char/unsigned char/;
  return $s;
}

sub build_tree_1($$$) {
  my ($abnodes, $index, $seen) = @_;

  if (defined ($seen->{$index})) {
    return $seen->{$index};
  }

  my $node;
  if (!(defined $abnodes->{$index})) {
    return "DANGLING $index";
  }
  my $abnode = $abnodes->{$index};
  my $node = {};
  $seen->{$index} = $node;
  while (my ($k, $v) = each %$abnode) {
    if ($v =~ /^\@/ && $k ne "index") {
      $v = build_tree_1($abnodes, $v, $seen);
    }
    $node->{$k} = $v;
  }

  return $node;
}

sub build_tree($$) {
  my ($abnodes, $index) = @_;
  my %tnodes = (); # HEY not using this.
  return build_tree_1($abnodes, $index, \%tnodes);
}

sub lookup($$) {
  my ($node, $path) = @_;
  my $v = mlookup($node, $path);
  if (!defined($v)) {
    print "==============\n";
    nshew(3, $node);
    croak "lookup $path" 
  }
  return $v;
}

sub tlookup($$) {
  my ($node, $paths) = @_;
  foreach my $path (@$paths) {
    my $v = mlookup($node, $path);
    return $v if defined($v);
  }
  print "==============\n";
  nshew(3, $node);
  shew($paths);
  croak "tlookup";
}

sub mlookup($$) {
  my ($node, $path) = @_;
  my @path = split(/\//, $path);
  while (@path > 0) {
    my $k = shift(@path);
    if (!defined $node->{$k}) {
      return undef;
    }
    $node = $node->{$k};
  }
  return $node;
}

sub defd($$) {
  my ($node, $path) = @_;
  my @path = split(/\//, $path);
  while (@path > 0) {
    my $k = shift(@path);
    if (!defined($node->{$k})) {
      return 0;
    }
    $node = $node->{$k};
  }
  return 1;
}

my $maxlevel = 5;
my $level = 0;

my $tabb = "| ";

sub dumpit($) {
  return if ($level >= $maxlevel);
  my ($node) = @_;
  if (ref $node eq "ARRAY") {
    print $tabb x $level;
    print "[]\n";
    for (my $i = 0; $i < @$node; ++$i) {
      my $v = $node->[$i];
      if (ref($v) eq "") {
        print $tabb x $level;
        print "$i: $v\n";
      } else {
        print $tabb x $level;
        print "[$i]:\n";
        $level++;
        dumpit($v);
        $level--;
      }
    }
  } elsif (ref $node eq "HASH") {
    print $tabb x $level;
    print "[$node->{nodetype}]\n";
    my @k = keys %$node;
    foreach my $k (keys %$node) {
      my $v = $node->{$k};
      if (ref($v) eq "") {
        print $tabb x $level;
        print "$k: $v\n";
      } else {
        print $tabb x $level;
        print "$k:\n";
        $level++;
        dumpit($v);
        $level--;
      }
    }
  } elsif (ref $node eq "") {
    print "$node\n";
  } else {
    die $node;
  }
}

sub chanwalk($) {
  my ($node) = @_;
  my $here = $node;
  my @rs = ();
  while (1) {
    push @rs, $here;
    if (ref $here eq "HASH" && defined $here->{"chan"}) {
      $here = $here->{"chan"};
    } else {
      last;
    }
  }
  return \@rs; 
}

sub id($) {
  my ($v) = @_;
  return $v;
}

my $unique_serial = 0;
sub unique($) {
  my ($prefix) = @_;
  return $prefix . ($unique_serial++);
}

sub name_undef($$) {
  my ($prefix, $v) = @_;
  if (!defined($v)) {
    return unique($prefix);
  } else {
    return $v;
  }
}

sub get_param_type($) {
  my ($f) = @_;

  if (lookup($f, "nodetype") eq "pointer_type" &&
      lookup($f, "ptd/nodetype") eq "function_type") {
    return get_function_type(lookup($f, "ptd"));
  }

  my $s = "";

  while (defd($f, "ptd")) {
    $s .= "*";
    $f = lookup($f, "ptd");
  }

  $s = lookup($f, "name/name/strg") . $s;
  if (mlookup($f, "qual") eq "c") {
    $s = "const $s";
  }
  return $s;
}

sub get_function_type($) {
  my ($fun) = @_;
  my $stuff = {};

  $stuff->{"name"} = name_undef("anonf", mlookup($fun, "name/strg"));
  print "NAME $stuff->{name}\n";

  my $params;
  my @nameses;
  my @typeses;
  if (defd($fun, "args")) {
    my $ipp = chanwalk(lookup($fun, "args"));
    @typeses = map { get_param_type(lookup($_, "argt")) } @$ipp;
    @nameses = map { name_undef("anonp", mlookup($_, "name/strg")) } @$ipp;
  } else {
    @typeses = map { get_param_type($_) } (map { lookup($_, "valu") } @{chanwalk(tlookup($fun, ["type/prms", "prms"]))});
    pop(@typeses) eq "void" || die;
    @nameses = map { unique("anonp") } @typeses;
  }
  $params = zip(\@typeses, \@nameses);
  $stuff->{"params"} = $params;

  if (defd($fun, 'type/retn')) {
    $stuff->{"return_type"} = get_param_type(lookup($fun, 'type/retn'));
  } else {
    $stuff->{"return_type"} = get_param_type(lookup($fun, "retn"));
  }

  return $stuff;
}

sub function_decls($) {
  my ($t) = @_;
  my $dcls = chanwalk(lookup($t, "dcls"));
  $dcls = [grep { $_->{"nodetype"} eq "function_decl"; } @$dcls];
  return $dcls;
}

sub funfile($) {
  my ($fun) = @_;
  my $filename = lookup($fun, "srcp");
  $filename =~ s/\:\d+$//;
  return $filename;
}

sub readem($) {
  my ($src) = @_;
  print "READING...\n";
  my $dumpfile = "$src.t00.tu";
  open(DUMP, $dumpfile) || die "$dumpfile: $!";
  my @lines = <DUMP>;
  close(DUMP);

  my %nodes;
  my $current;
  my $current_id;
  foreach my $line (@lines) {
    chomp($line);

    $line = burp($line);

    if ($line =~ /^(\@\d+)\s+(\S+)/) {
      if ($current_id) {
        $nodes{$current_id} = $current;
      }
      $current_id = $1;
      $current = {};
      $current->{"nodetype"} = $2;
      $current->{"index"} = $current_id;
    } else {
      die if (!defined($current) || !defined($current_id));
    }

    my %stuff;
    foreach my $gark (55, 40, 25) {
      #print "-- $line\n";
      #print "- " . substr($line, $gark - 1) . "\n";
      if (substr($line, ($gark - 1)) =~ /^ \S/) {
        my $bluh = substr($line, $gark);
        if ($bluh =~ /^(\S...): (.*)$/) {
          my $k = $1;
          my $v = $2;
          $v = unburp($v);
          #print "$k=$v\n";
          $stuff{trim($k)} = trim($v);
        } else {
          $bluh = trim($bluh);
          $stuff{$bluh} = 1;
        }
        $line = substr($line, 0, $gark);
      }
    }

    $current = {%$current, %stuff};
  }
  if ($current_id) {
    $nodes{$current_id} = $current;
  }
  return \%nodes;
}

sub read_dump($) {
  my ($src) = @_;
  my $abnodes = readem($src);

  print "BUILDING TREE...\n";
  my $tree = build_tree($abnodes, "\@1");

  my $dcls = function_decls($tree);

  my @funs = ();
  for (my $i = 0; $i < @$dcls; ++$i) {
    my $fun = $dcls->[$i];
    if (member(funfile($fun), \@files)) {
      shew($i);
      push(@funs, get_function_type($fun));
    }
  }

  return \@funs;
}

sub sig($) {
  my ($fun) = @_;
  my $sig = "";

  my $params = join(", ",
                    map { "$_->[0] $_->[1]" } @{$fun->{"params"}});

  $sig .= $fun->{"return_type"};
  $sig .= " ";
  $sig .= $fun->{"name"};
  $sig .= "(";
  $sig .= $params;
  $sig .= ")";

  return $sig;
}

sub opaque_wrap($$) {
  my ($type, $var) = @_;
  if (member($type, \@integer_types)) {
    return "integer((int)$var)";
#  } elsif ($type eq "float") {
#    return "flote($var)";
#  } elsif ($type eq "double" || $type eq "GLdouble" || $type eq "GLfloat") {
  } elsif (member($type, \@float_types)) {
    return "flote((float)$var)";
  } else {
    return "opaque((void*)$var)";
  }
}

sub opaque_unwrap($$) {
  my ($type, $var) = @_;
  if (member($type, \@integer_types)) {
    return "getint($var)";
#  } elsif ($type eq "float" || $type eq "double" || $type eq "GLdouble" || $type eq "GLfloat") {
  } elsif (member($type, \@float_types)) {
    return "getfloat($var)";
  } else {
    return "opaqueval($var)";
  }
}

sub declare_var($$) {
  my ($type, $name) = @_;
  if (ref($type) eq "") {
    return "$type $name";
  } else {
    # Assume it's a fun.
    $type = {%$type};
    $type->{"name"} = "(*$name)";
    return sig($type);
  }
}

sub castit($) {
  my ($type) = @_;
  if (ref($type) eq "") {
    return $type;
  } else {
    # Assume it's a fun.
    $type = {%$type};
    $type->{"name"} = "(*)";
    return sig($type);
  }
}

sub gen_cbody($) {
  my ($fun) = @_;
  #print sig($fun);

  my $s = "";

  my $name = $fun->{"name"};
  my $return_type = $fun->{"return_type"};
  my $arg = unique("arg");

  $s .= "yeah* foop_$name(yeah* $arg) {\n";

  my $here = unique("here");
  $s .= "  yeah* $here = $arg;\n";

  my @names = ();
  foreach my $p (@{$fun->{"params"}}) {
    my ($type, $name) = @$p;
    my $decl = declare_var($type, $name);
    my $caster = castit($type);

    push(@names, $name);

    my $harg = unique("harg");
    $s .= "  yeah* $harg = hcar($here);\n";
    $s .= "  $decl = ($caster)" . opaque_unwrap($type, $harg) . ";\n";
    $s .= "  $here = hcdr($here);\n";
  }
  $s .= "  A(isnil($here));\n";

  my $funcall = "$name(" . join(", ", @names) . ")";
  if ($return_type eq "void") {
    $s .= "  $funcall;\n";
    $s .= "  return Nil;\n";
  } else {
    my $ret = unique("ret");
    my $rdecl = declare_var($return_type, $ret);
    $s .= "  $rdecl = $funcall;\n";
    $s .= "  return " . opaque_wrap($return_type, $ret) . ";\n";
  }
  $s .= "}\n";

  return $s;
}

sub genregisterer($$) {
  my ($module, $dcls) = @_;
  my $s = "";
  $s .= "void ${module}_impl_register() {\n";
  for (my $i = 0; $i < @$dcls; ++$i) {
    my $fun = $dcls->[$i];
    my $name = $fun->{"name"};
    $s .= "  register_command(\"$name\", &foop_$name);\n";
  }
  $s .= "}\n";
  return $s;
}

sub impl_c($$) {
  my ($module, $dcls) = @_;
  my $s = "";
  $s .= $c_header;
  $s .= $extern_c_top;
  $s .= qq[#include "butt.h"\n];
  $s .= qq[#include "$module.impl.h"\n];
  for (my $i = 0; $i < @$dcls; ++$i) {
    my $fun = $dcls->[$i];
    $s .= gen_cbody($fun);
  }
  $s .= genregisterer($module, $dcls);
  $s .= $extern_c_bottom;
  return $s;
}

sub impl_h($) {
  my ($module) = @_;
  my $s = "";
  $s .= $extern_c_top;
  $s .= "extern void ${module}_impl_register();\n";
  $s .= $extern_c_bottom;
}

sub stub($$) {
  my ($module, $dcls) = @_;
  my $s = "";
  for (my $i = 0; $i < @$dcls; ++$i) {
    my $fun = $dcls->[$i];
    my $name = $fun->{"name"};
    my $hname = $name;
    $hname =~ s/_/-/g;
    my @param_names = map { $_->[1] } @{$fun->{"params"}};
    my @ha = ($hname, @param_names);
    my $ha = join(" ", @ha);
    my @ho = ("\$", @param_names);
    my $ho = join(" ", @ho);
    $s .= "(fun ($ha) (Command \'$name ($ho)))\n";
  }
  writeFile("$module.stub.ss", $s);
}

sub impl($$) {
  my ($module, $funs) = @_;
  my $c = impl_c($module, $funs);
  my $h = impl_h($module);
  writeFile("$module.impl.c", $c);
  writeFile("$module.impl.h", $h);
}

sub go() {
  my $module = $ARGV[0];
  my $src = $module . ".c";
  my $funs = read_dump($src);
  impl($module, $funs);
  stub($module, $funs);
}

go();
