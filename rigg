#!/usr/bin/env perl

$|=1;

use strict;

use Data::Dumper;

sub psshew
{
  my @things = @_;
  my $s = "";

  foreach my $thing (@things) {
    my $dumped;

    local $Data::Dumper::Terse = 1;
    local $Data::Dumper::Indent = 1;

    $dumped = +Dumper( $thing );
    $dumped =~ s/\n$//;

    $s .= "$dumped\n";
  }
  return $s;
}

sub shew( @ )
{
  foreach (@_) {
    print psshew($_);
  }
}


print "READING...\n";
my @lines = <>;

my $all = join('', @lines);
$all =~ s/\n( +)/ /gm;
my @nodelines = split(/\n/, $all);
#shew(\@nodelines);

my %abnodes = ();

print "PARSING...\n";
foreach my $nodeline (@nodelines) {
  my @words = split(/\s+/, $nodeline);
  #print join(":::", @words) . "\n";
  my %node = ();
  $node{"index"} = shift(@words);
  $node{"nodetype"} = shift(@words);
  while (@words > 0) {
    if ($words[0] =~ /:$/) {
      my $k = shift(@words);
      my $v = shift(@words);

      $k =~ s/:$// || die "\"$k\"";

      $node{$k} = $v;
    } else {
      my $k = shift(@words);
      $node{$k} = 1;
    }
  }

  $abnodes{$node{"index"}} = \%node;
}

sub build_tree_1($$) {
  my ($index, $seen) = @_;

  if (defined ($seen->{$index})) {
    return $seen->{$index};
  }

  my $node;
  if (!(defined $abnodes{$index})) {
    return "DANGLING";
  }
  my $abnode = $abnodes{$index};
  my $node = {};
  $seen->{$index} = $node;
  while (my ($k, $v) = each %$abnode) {
    if ($v =~ /^\@/ && $k ne "index") {
      $v = build_tree_1($v, $seen);
    }
    $node->{$k} = $v;
  }

  return $node;
}

sub build_tree($) {
  my ($index) = @_;
  return build_tree_1($index, {});
}

sub lookup($$) {
  my ($node, $path) = @_;
  my @path = split(/\//, $path);
  while (@path > 0) {
    my $k = shift(@path);
    die "$node: $path" if (!defined $node->{$k});
    $node = $node->{$k};
  }
  return $node;
}

my $maxlevel = 4;
my $level = 0;

my $tabb = "| ";

sub dumpit($) {
  return if ($level >= $maxlevel);
  my ($node) = @_;
  if (ref $node eq "ARRAY") {
    print $tabb x $level;
    print "[]\n";
    for (my $i = 0; $i < @$node; ++$i) {
      my $v = $node->[$i];
      if (ref($v) eq "") {
        print $tabb x $level;
        print "$i: $v\n";
      } else {
        print $tabb x $level;
        print "[$i]:\n";
        $level++;
        dumpit($v);
        $level--;
      }
    }
  } elsif (ref $node eq "HASH") {
    print $tabb x $level;
    print "[$node->{nodetype}]\n";
    my @k = keys %$node;
    foreach my $k (keys %$node) {
      my $v = $node->{$k};
      if (ref($v) eq "") {
        print $tabb x $level;
        print "$k: $v\n";
      } else {
        print $tabb x $level;
        print "$k:\n";
        $level++;
        dumpit($v);
        $level--;
      }
    }
  } elsif (ref $node eq "") {
    print "$node\n";
  } else {
    die $node;
  }
}

print "BUILDING TREE...\n";
#shew(\%abnodes);
my $tree = build_tree("\@1");
#shew($tree);

#shew(lookup($tree, "dcls"));
#dumpit(lookup($tree, "dcls"));
my $dcls = lookup($tree, "dcls");

sub chanmap($$) {
  my ($f, $node) = @_;
  my $here = $node;
  my @rs = ();
  while (1) {
    my $r = $f->($here);
    push @rs, $r;
    if (ref $here eq "HASH" && defined $here->{"chan"}) {
      $here = $here->{"chan"};
    } else {
      last;
    }
  }
  return \@rs; 
}

sub id($) {
  my ($v) = @_;
  return $v;
}

sub gettype($) {
  my ($n) = @_;
  my $name = lookup($n, "name/strg");
  my $type = lookup($n, "argt");
  $type = lookup($type, "nodetype");
#  my $type = 2;
  return [$name, $type];
}

sub glimp($) {
  my ($n) = @_;
  my $name = lookup($n, "name/strg");
  my $args = chanmap(\&gettype, lookup($n, "args"));
  return [$name, $args];
}

$dcls = chanmap(\&id, $dcls);
my $keyboard = $dcls->[6];
#dumpit($keyboard);

my $hoo = glimp($keyboard);
#shew($hoo);

#dcls/chan/chan/chan/chan/chan/chan/type/prms/valu/name/name/strg
my $ret = lookup($tree, "dcls/chan/chan/chan/chan/chan/chan/type/retn/name/name/strg");
print "ret $ret\n";
my $vo = lookup($tree, "dcls/chan/chan/chan/chan/chan/chan/type/prms/valu/name/name/strg");
# HERE should be paring this as 'strg: unsigned char'
dumpit($vo);
