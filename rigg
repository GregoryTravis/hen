#!/usr/bin/env perl

$|=1;

use strict;

use Data::Dumper;

sub psshew
{
  my @things = @_;
  my $s = "";

  foreach my $thing (@things) {
    my $dumped;

    local $Data::Dumper::Terse = 1;
    local $Data::Dumper::Indent = 1;

    $dumped = +Dumper( $thing );
    $dumped =~ s/\n$//;

    $s .= "$dumped\n";
  }
  return $s;
}

sub shew( @ )
{
  foreach (@_) {
    print psshew($_);
  }
}


print "READING...\n";
my @lines = <>;

#0123456789012345678901234567890123456789012345678901234567890123456789
#@1570   const_decl       name: @1622    type: @1479    srcp: cg.h:216    

sub trim($) {
  my $s = shift;
  $s =~ s/^\s*//;
  $s =~ s/\s*$//;
  return $s;
}

# Turn "unsigned char" to "unsigned_char", e.g., to prevent 'char'
# from seeming like it's in a different column.
sub burp($) {
  my ($s) = @_;
  $s =~ s/unsigned char/unsigned_char/;
  return $s;
}

my %nodes;
my $current;
my $current_id;
foreach my $line (@lines) {
  chomp($line);

  $line = burp($line);

  if ($line =~ /^(\@\d+)\s+(\S+)/) {
    if ($current_id) {
      $nodes{$current_id} = $current;
    }
    $current_id = $1;
    $current = {};
    $current->{"nodetype"} = $2;
    $current->{"index"} = $current_id;
  } else {
    die if (!defined($current) || !defined($current_id));
  }

  my %stuff;
  foreach my $gark (55, 40, 25) {
    #print "-- $line\n";
    #print "- " . substr($line, $gark - 1) . "\n";
    if (substr($line, ($gark - 1)) =~ /^ \S/) {
      my $bluh = substr($line, $gark);
      if ($bluh =~ /^(\S...): (.*)$/) {
        my $k = $1;
        my $v = $2;
        #print "$k=$v\n";
        $stuff{trim($k)} = trim($v);
      } else {
        $bluh = trim($bluh);
        $stuff{$bluh} = 1;
      }
      $line = substr($line, 0, $gark);
    }
  }

  $current = {%$current, %stuff};
}
if ($current_id) {
  $nodes{$current_id} = $current;
}

=a
#shew(\%nodes);
shew($nodes{"\@3692"});

exit;

my $all = join('', @lines);
$all =~ s/\n( +)/ /gm;
my @nodelines = split(/\n/, $all);
#shew(\@nodelines);

my %abnodes = ();

print "PARSING...\n";
foreach my $nodeline (@nodelines) {
  my @words = split(/\s+/, $nodeline);
  #print join(":::", @words) . "\n";
  my %node = ();
  $node{"index"} = shift(@words);
  $node{"nodetype"} = shift(@words);
  while (@words > 0) {
    if ($words[0] =~ /:$/) {
      my $k = shift(@words);
      my $v = shift(@words);

      $k =~ s/:$// || die "\"$k\"";

      $node{$k} = $v;
    } else {
      my $k = shift(@words);
      $node{$k} = 1;
    }
  }

  $abnodes{$node{"index"}} = \%node;
}
=cut

my %abnodes = %nodes;

sub build_tree_1($$) {
  my ($index, $seen) = @_;

  if (defined ($seen->{$index})) {
    return $seen->{$index};
  }

  my $node;
  if (!(defined $abnodes{$index})) {
    return "DANGLING $index";
  }
  my $abnode = $abnodes{$index};
  my $node = {};
  $seen->{$index} = $node;
  while (my ($k, $v) = each %$abnode) {
    if ($v =~ /^\@/ && $k ne "index") {
      $v = build_tree_1($v, $seen);
    }
    $node->{$k} = $v;
  }

  return $node;
}

my %tnodes = ();
sub build_tree($) {
  my ($index) = @_;
  return build_tree_1($index, \%tnodes);
}

sub lookup($$) {
  my ($node, $path) = @_;
  my @path = split(/\//, $path);
  while (@path > 0) {
    my $k = shift(@path);
    if (!defined $node->{$k}) {
      print "==============\n";
      dumpit($node);
      die "$node: $path" 
    }
    $node = $node->{$k};
  }
  return $node;
}

sub defd($$) {
  my ($node, $path) = @_;
  my @path = split(/\//, $path);
  while (@path > 0) {
    my $k = shift(@path);
    if (!defined($node->{$k})) {
      return 0;
    }
    $node = $node->{$k};
  }
  return 1;
}

my $maxlevel = 5;
my $level = 0;

my $tabb = "| ";

sub dumpit($) {
  return if ($level >= $maxlevel);
  my ($node) = @_;
  if (ref $node eq "ARRAY") {
    print $tabb x $level;
    print "[]\n";
    for (my $i = 0; $i < @$node; ++$i) {
      my $v = $node->[$i];
      if (ref($v) eq "") {
        print $tabb x $level;
        print "$i: $v\n";
      } else {
        print $tabb x $level;
        print "[$i]:\n";
        $level++;
        dumpit($v);
        $level--;
      }
    }
  } elsif (ref $node eq "HASH") {
    print $tabb x $level;
    print "[$node->{nodetype}]\n";
    my @k = keys %$node;
    foreach my $k (keys %$node) {
      my $v = $node->{$k};
      if (ref($v) eq "") {
        print $tabb x $level;
        print "$k: $v\n";
      } else {
        print $tabb x $level;
        print "$k:\n";
        $level++;
        dumpit($v);
        $level--;
      }
    }
  } elsif (ref $node eq "") {
    print "$node\n";
  } else {
    die $node;
  }
}

sub chanmap($$) {
  my ($f, $node) = @_;
  my $here = $node;
  my @rs = ();
  while (1) {
    my $r = $f->($here);
    push @rs, $r;
    if (ref $here eq "HASH" && defined $here->{"chan"}) {
      $here = $here->{"chan"};
    } else {
      last;
    }
  }
  return \@rs; 
}

sub id($) {
  my ($v) = @_;
  return $v;
}

sub gettype($) {
  my ($n) = @_;
  my $name = lookup($n, "name/strg");
  my $type = lookup($n, "argt");
  $type = lookup($type, "nodetype");
#  my $type = 2;
  return [$name, $type];
}

sub glimp($) {
  my ($n) = @_;
  my $name = lookup($n, "name/strg");
  my $args = chanmap(\&gettype, lookup($n, "args"));
  return [$name, $args];
}

print "BUILDING TREE...\n";
my $tree = build_tree("\@1");

my $anon_inx = 0;

sub gurt($) {
  my ($fun) = @_;
#dumpit($fun);
  my $stuff = {};
  $stuff->{"name"} = lookup($fun, "name/strg");
print "NAME $stuff->{name}\n";
  if (defd($fun, "type/retn/name/name/strg")) {
    $stuff->{"return_type"} = lookup($fun, "type/retn/name/name/strg");
  } else {
    $stuff->{"return_type"} = lookup($fun, "type/retn/ptd/name/name/strg");
  }

  my @params = ();
  if (defd($fun, "args")) {
    my $pts = "type/prms";
    my $pns = "args";
    while (1) {
      my $type;
      if (defd($fun, "$pts/valu/name/name/strg")) {
        $type = lookup($fun, "$pts/valu/name/name/strg");
      } else {
        $type = lookup($fun, "$pts/valu/ptd/name/name/strg");
        $type .= "*";
      }
      my $name;
      if (defd($fun, "$pns/name/strg")) {
        $name = lookup($fun, "$pns/name/strg");
      } else {
        $name = "anon_" . ($anon_inx++);
      }
      #print "HA $type $name\n";
      push(@params, [$type, $name]);

      if (!defd($fun, "$pns/chan")) {
        last;
      }

      $pts .= "/chan";
      $pns .= "/chan";
    }
  }

  $stuff->{"params"} = \@params;

  return $stuff;
}

sub function_decls($) {
  my ($t) = @_;
  my $dcls = chanmap(\&id, lookup($t, "dcls"));
  $dcls = [grep { $_->{"nodetype"} eq "function_decl"; } @$dcls];
  return $dcls;
}

my $dcls = function_decls($tree);
#$dcls = [grep { $_->{"srcp"} =~ /^vertex_and_fragment_program.c/; } @$dcls];
for (my $i = 0; $i < @$dcls; ++$i) {
  my $fun = $dcls->[$i];
  shew($i++);
  shew($fun->{"nodetype"});
  shew(gurt($fun));
}
