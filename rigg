#!/usr/bin/env perl

$|=1;

use strict;

use Data::Dumper;

sub psshew
{
  my @things = @_;
  my $s = "";

  foreach my $thing (@things) {
    my $dumped;

    local $Data::Dumper::Terse = 1;
    local $Data::Dumper::Indent = 1;

    $dumped = +Dumper( $thing );
    $dumped =~ s/\n$//;

    $s .= "$dumped\n";
  }
  return $s;
}

sub shew( @ )
{
  foreach (@_) {
    print psshew($_);
  }
}


print "READING...\n";
my @lines = <>;

#0123456789012345678901234567890123456789012345678901234567890123456789
#@1570   const_decl       name: @1622    type: @1479    srcp: cg.h:216    

sub trim($) {
  my $s = shift;
  $s =~ s/^\s*//;
  $s =~ s/\s*$//;
  return $s;
}

my %nodes;
my $current;
my $current_id;
foreach my $line (@lines) {
  chomp($line);
  if ($line =~ /^(\@\d+)\s+(\S+)/) {
    if ($current_id) {
      $nodes{$current_id} = $current;
    }
    $current_id = $1;
    $current = {};
    $current->{"nodetype"} = $2;
    $current->{"index"} = $current_id;
  } else {
    die if (!defined($current) || !defined($current_id));
  }

  my %stuff;
  foreach my $gark (55, 40, 25) {
    #print "-- $line\n";
    #print "- " . substr($line, $gark - 1) . "\n";
    if (substr($line, ($gark - 1)) =~ /^ \S/) {
      my $bluh = substr($line, $gark);
      if ($bluh =~ /^(\S...): (.*)$/) {
        my $k = $1;
        my $v = $2;
        #print "$k=$v\n";
        $stuff{trim($k)} = trim($v);
      } else {
        $bluh = trim($bluh);
        $stuff{$bluh} = 1;
      }
      $line = substr($line, 0, $gark);
    }
  }

  $current = {%$current, %stuff};
}
if ($current_id) {
  $nodes{$current_id} = $current;
}

=a
#shew(\%nodes);
shew($nodes{"\@3692"});

exit;

my $all = join('', @lines);
$all =~ s/\n( +)/ /gm;
my @nodelines = split(/\n/, $all);
#shew(\@nodelines);

my %abnodes = ();

print "PARSING...\n";
foreach my $nodeline (@nodelines) {
  my @words = split(/\s+/, $nodeline);
  #print join(":::", @words) . "\n";
  my %node = ();
  $node{"index"} = shift(@words);
  $node{"nodetype"} = shift(@words);
  while (@words > 0) {
    if ($words[0] =~ /:$/) {
      my $k = shift(@words);
      my $v = shift(@words);

      $k =~ s/:$// || die "\"$k\"";

      $node{$k} = $v;
    } else {
      my $k = shift(@words);
      $node{$k} = 1;
    }
  }

  $abnodes{$node{"index"}} = \%node;
}
=cut

my %abnodes = %nodes;

sub build_tree_1($$) {
  my ($index, $seen) = @_;

  if (defined ($seen->{$index})) {
    return $seen->{$index};
  }

  my $node;
  if (!(defined $abnodes{$index})) {
    return "DANGLING $index";
  }
  my $abnode = $abnodes{$index};
  my $node = {};
  $seen->{$index} = $node;
  while (my ($k, $v) = each %$abnode) {
    if ($v =~ /^\@/ && $k ne "index") {
      $v = build_tree_1($v, $seen);
    }
    $node->{$k} = $v;
  }

  return $node;
}

sub build_tree($) {
  my ($index) = @_;
  return build_tree_1($index, {});
}

sub lookup($$) {
  my ($node, $path) = @_;
  my @path = split(/\//, $path);
  while (@path > 0) {
    my $k = shift(@path);
    die "$node: $path" if (!defined $node->{$k});
    $node = $node->{$k};
  }
  return $node;
}

my $maxlevel = 5;
my $level = 0;

my $tabb = "| ";

sub dumpit($) {
  return if ($level >= $maxlevel);
  my ($node) = @_;
  if (ref $node eq "ARRAY") {
    print $tabb x $level;
    print "[]\n";
    for (my $i = 0; $i < @$node; ++$i) {
      my $v = $node->[$i];
      if (ref($v) eq "") {
        print $tabb x $level;
        print "$i: $v\n";
      } else {
        print $tabb x $level;
        print "[$i]:\n";
        $level++;
        dumpit($v);
        $level--;
      }
    }
  } elsif (ref $node eq "HASH") {
    print $tabb x $level;
    print "[$node->{nodetype}]\n";
    my @k = keys %$node;
    foreach my $k (keys %$node) {
      my $v = $node->{$k};
      if (ref($v) eq "") {
        print $tabb x $level;
        print "$k: $v\n";
      } else {
        print $tabb x $level;
        print "$k:\n";
        $level++;
        dumpit($v);
        $level--;
      }
    }
  } elsif (ref $node eq "") {
    print "$node\n";
  } else {
    die $node;
  }
}

sub chanmap($$) {
  my ($f, $node) = @_;
  my $here = $node;
  my @rs = ();
  while (1) {
    my $r = $f->($here);
    push @rs, $r;
    if (ref $here eq "HASH" && defined $here->{"chan"}) {
      $here = $here->{"chan"};
    } else {
      last;
    }
  }
  return \@rs; 
}

sub id($) {
  my ($v) = @_;
  return $v;
}

sub gettype($) {
  my ($n) = @_;
  my $name = lookup($n, "name/strg");
  my $type = lookup($n, "argt");
  $type = lookup($type, "nodetype");
#  my $type = 2;
  return [$name, $type];
}

sub glimp($) {
  my ($n) = @_;
  my $name = lookup($n, "name/strg");
  my $args = chanmap(\&gettype, lookup($n, "args"));
  return [$name, $args];
}

print "BUILDING TREE...\n";
#shew(\%abnodes);
my $tree = build_tree("\@1");
#dumpit($tree);
#shew($tree);
#shew(\%nodes);

#shew(lookup($tree, "dcls"));
#dumpit(lookup($tree, "dcls"));
my $dcls = lookup($tree, "dcls");

$dcls = chanmap(\&id, $dcls);
my $keyboard = $dcls->[6];
dumpit($keyboard);
exit;

my $hoo = glimp($keyboard);
#shew($hoo);

#dcls/chan/chan/chan/chan/chan/chan/type/prms/valu/name/name/strg
my $ret = lookup($tree, "dcls/chan/chan/chan/chan/chan/chan/type/retn/name/name/strg");
print "ret $ret\n";
my $vo = lookup($tree, "dcls/chan/chan/chan/chan/chan/chan/type/prms/valu/name/name/strg");
dumpit($vo);
