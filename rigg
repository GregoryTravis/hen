#!/usr/bin/env perl

$|=1;

use strict;

use Data::Dumper;

my %nodes;
my %abnodes;
my %tnodes = ();

sub member($$) {
  my ($e, $list) = @_;
  foreach my $ee (@$list) {
    return 1 if ($e eq $ee);
  }
  return 0;
}

sub psshew
{
  my @things = @_;
  my $s = "";

  foreach my $thing (@things) {
    my $dumped;

    local $Data::Dumper::Terse = 1;
    local $Data::Dumper::Indent = 1;
    #local $Data::Dumper::Maxdepth = 2;
    local $Data::Dumper::Sortkeys = 1;

    $dumped = +Dumper( $thing );
    $dumped =~ s/\n$//;

    $s .= "$dumped\n";
  }
  return $s;
}

sub nshew {
  my ($depth, $thing) = @_;
  my $s = "";

  my $dumped;

  local $Data::Dumper::Terse = 1;
  local $Data::Dumper::Indent = 1;
  local $Data::Dumper::Maxdepth = $depth;
  local $Data::Dumper::Sortkeys = 1;

  $dumped = +Dumper( $thing );
  $dumped =~ s/\n$//;

  $s .= "$dumped\n";
  print $s;
}

sub shew( @ )
{
  foreach (@_) {
    print psshew($_);
  }
}

sub zip($$) {
  my ($a, $b) = @_;
  die (@$a . "!=" . @$b) unless (@$a == @$b);
  my @z = ();
  for (my $i = 0; $i < @$a; ++$i) {
    $z[$i] = [ $a->[$i], $b->[$i] ];
  }
  return \@z;
}

sub trim($) {
  my $s = shift;
  $s =~ s/^\s*//;
  $s =~ s/\s*$//;
  return $s;
}

# Turn "unsigned char" to "unsigned_char", e.g., to prevent 'char'
# from seeming like it's in a different column.
sub burp($) {
  my ($s) = @_;
  $s =~ s/unsigned char/unsigned_char/;
  return $s;
}

sub build_tree_1($$) {
  my ($index, $seen) = @_;

  if (defined ($seen->{$index})) {
    return $seen->{$index};
  }

  my $node;
  if (!(defined $abnodes{$index})) {
    return "DANGLING $index";
  }
  my $abnode = $abnodes{$index};
  my $node = {};
  $seen->{$index} = $node;
  while (my ($k, $v) = each %$abnode) {
    if ($v =~ /^\@/ && $k ne "index") {
      $v = build_tree_1($v, $seen);
    }
    $node->{$k} = $v;
  }

  return $node;
}

sub build_tree($) {
  my ($index) = @_;
  return build_tree_1($index, \%tnodes);
}

sub lookup($$) {
  my ($node, $path) = @_;
  my $v = mlookup($node, $path);
  if (!defined($v)) {
    print "==============\n";
    shew($node);
    die "lookup $path" 
  }
  return $v;
}

sub mlookup($$) {
  my ($node, $path) = @_;
  my @path = split(/\//, $path);
  while (@path > 0) {
    my $k = shift(@path);
    if (!defined $node->{$k}) {
      return undef;
    }
    $node = $node->{$k};
  }
  return $node;
}

sub defd($$) {
  my ($node, $path) = @_;
  my @path = split(/\//, $path);
  while (@path > 0) {
    my $k = shift(@path);
    if (!defined($node->{$k})) {
      return 0;
    }
    $node = $node->{$k};
  }
  return 1;
}

my $maxlevel = 5;
my $level = 0;

my $tabb = "| ";

sub dumpit($) {
  return if ($level >= $maxlevel);
  my ($node) = @_;
  if (ref $node eq "ARRAY") {
    print $tabb x $level;
    print "[]\n";
    for (my $i = 0; $i < @$node; ++$i) {
      my $v = $node->[$i];
      if (ref($v) eq "") {
        print $tabb x $level;
        print "$i: $v\n";
      } else {
        print $tabb x $level;
        print "[$i]:\n";
        $level++;
        dumpit($v);
        $level--;
      }
    }
  } elsif (ref $node eq "HASH") {
    print $tabb x $level;
    print "[$node->{nodetype}]\n";
    my @k = keys %$node;
    foreach my $k (keys %$node) {
      my $v = $node->{$k};
      if (ref($v) eq "") {
        print $tabb x $level;
        print "$k: $v\n";
      } else {
        print $tabb x $level;
        print "$k:\n";
        $level++;
        dumpit($v);
        $level--;
      }
    }
  } elsif (ref $node eq "") {
    print "$node\n";
  } else {
    die $node;
  }
}

sub chanwalk($) {
  my ($node) = @_;
  my $here = $node;
  my @rs = ();
  while (1) {
    push @rs, $here;
    if (ref $here eq "HASH" && defined $here->{"chan"}) {
      $here = $here->{"chan"};
    } else {
      last;
    }
  }
  return \@rs; 
}

sub id($) {
  my ($v) = @_;
  return $v;
}

my $undef_unique_serial = 0;
sub name_undef($$) {
  my ($prefix, $v) = @_;
  if (!defined($v)) {
    return $prefix . ($undef_unique_serial++);
  } else {
    return $v;
  }
}

sub getparam($) {
  my ($t) = @_;
  my $stars = "";
  if (lookup($t, "nodetype") eq "pointer_type" &&
      lookup($t, "ptd/nodetype") eq "function_type") {
    return gurt(lookup($t, "ptd"));
  }
  while (!defd($t, "name/name/strg")) {
    defd($t, "ptd") || die;
    $stars .= "*";
    $t = lookup($t, "ptd");
  }
  my $type = lookup($t, "name/name/strg");
  $type .= $stars;
  return $type;
}

sub gurt($) {
  my ($fun) = @_;
  my $stuff = {};
  $stuff->{"name"} = name_undef("anonf", mlookup($fun, "name/strg"));
  print "NAME $stuff->{name}\n";

  if (defd($fun, 'retn/name/name/strg')) {
    $stuff->{"return_type"} = lookup($fun, 'retn/name/name/strg');
  } else {
    #nshew(3, mlookup($fun, 'retn/name/name/strg'));
    $stuff->{"return_type"} = getparam(lookup($fun, "type/retn"));
  }

  if (defd($fun, "args")) {
    my @paramtypes = map { getparam($_); } (map { lookup($_, "valu"); } @{chanwalk(lookup($fun, "type/prms"))});
    #die $paramtypes[$#paramtypes] unless $paramtypes[$#paramtypes] eq "void";
    #shew("bug", $stuff->{name}, $paramtypes[$#paramtypes]);
    my @paramnames = map { name_undef("anonp", $_) } (map { mlookup($_, "name/strg"); } (@{chanwalk(lookup($fun, "args"))}));

    # Trailing char* for e.g. varargs asprintf; everything else has trailing void
    if ((scalar @paramtypes)-1 == (scalar @paramnames)) {
      @paramtypes = @paramtypes[0..$#paramtypes-1];
    }

    my @params = zip(\@paramtypes, \@paramnames);
    $stuff->{"params"} = \@params;
    #nshew(5, \@params);
  } else {
    $stuff->{"params"} = [];
  }

  return $stuff;
}

sub function_decls($) {
  my ($t) = @_;
  my $dcls = chanwalk(lookup($t, "dcls"));
#shew($dcls);
  $dcls = [grep { $_->{"nodetype"} eq "function_decl"; } @$dcls];
  return $dcls;
}

sub funfile($) {
  my ($fun) = @_;
  my $filename = lookup($fun, "srcp");
  $filename =~ s/\:\d+$//;
  return $filename;
}

sub readem() {
  print "READING...\n";
  my @lines = <>;

  my %nodes;
  my $current;
  my $current_id;
  foreach my $line (@lines) {
    chomp($line);

    $line = burp($line);

    if ($line =~ /^(\@\d+)\s+(\S+)/) {
      if ($current_id) {
        $nodes{$current_id} = $current;
      }
      $current_id = $1;
      $current = {};
      $current->{"nodetype"} = $2;
      $current->{"index"} = $current_id;
    } else {
      die if (!defined($current) || !defined($current_id));
    }

    my %stuff;
    foreach my $gark (55, 40, 25) {
      #print "-- $line\n";
      #print "- " . substr($line, $gark - 1) . "\n";
      if (substr($line, ($gark - 1)) =~ /^ \S/) {
        my $bluh = substr($line, $gark);
        if ($bluh =~ /^(\S...): (.*)$/) {
          my $k = $1;
          my $v = $2;
          #print "$k=$v\n";
          $stuff{trim($k)} = trim($v);
        } else {
          $bluh = trim($bluh);
          $stuff{$bluh} = 1;
        }
        $line = substr($line, 0, $gark);
      }
    }

    $current = {%$current, %stuff};
  }
  if ($current_id) {
    $nodes{$current_id} = $current;
  }
  %abnodes = %nodes;
}

sub go() {
  readem();

  print "BUILDING TREE...\n";
  my $tree = build_tree("\@1");

  my @files = ("vertex_and_fragment_program.c", "cg.h", "cgGL.h", "cgGL_profiles.h",
               "cg_bindlocations.h", "cg_datatypes.h", "cg_enums.h", "cg_errors.h",
               "cg_profiles.h", "gl.h", "glext.h", "glu.h", "glut.h");

  my $dcls = function_decls($tree);
  for (my $i = 0; $i < @$dcls; ++$i) {
    my $fun = $dcls->[$i];
    if (member(funfile($fun), \@files)) {
      shew($i);
      shew("SRC", lookup($fun, "srcp"));
      #nshew(5, $fun);
      nshew(4, gurt($fun));
    }
  }
}

go();

sub gen($) {
  my ($fun) = @_;
  my $sig = "";

  my $params = join(", ",
                    map { "$_->[0] $_->[1]" } @{$fun->{"params"}});

  $sig .= $fun->{"return_type"};
  $sig .= "";
  $sig .= $fun->{"name"};
  $sig .= "(";
  $sig .= $params;
  $sig .= ")";

  print $sig;
}

my $oot = 
{
  'name' => 'glutInitDisplayMode',
  'params' => [
    [
      [
        'unsigned',
        'mode'
      ]
    ]
  ],
  'return_type' => 'void'
};

#gen($oot);
