(require (lib "32.ss" "srfi"))
(require (lib "13.ss" "srfi"))
(require (lib "defmacro.ss"))
(require (lib "process.ss"))
(require (lib "compat.ss"))
(require (lib "pretty.ss"))
(require-for-syntax (lib "list.ss"))

(define concat string-append)

(define (call-with-output-string pf)
  (let ((p (open-output-string)))
    (pf p)
    (get-output-string p)))

(define (read-objects filename)
  (call-with-input-file filename read-objects-port))

(define (read-objects-port p)
  (letrec ((objects '())
           (read-em
            (lambda ()
              (let ((object (read p)))
                (if (eof-object? object)
                    objects
                    (begin
                      (set! objects (cons object objects))
                      (read-em)))))))
    (reverse (read-em))))

(define (pp . rest)
  (map pretty-print rest))

(define (spp . rest)
  (call-with-output-string
   (lambda (port)
     (map (lambda (o) (pretty-print o port)) rest))))

(define (sdisplay . rest)
  (call-with-output-string
   (lambda (port)
     (map (lambda (o) (display o port)) rest))))

(define (swrite . rest)
  (call-with-output-string
   (lambda (port)
     (map (lambda (o) (write o port)) rest))))

(define (shew . args)
  (map pretty-print args)
  (flush-output))

(define (say . args)
  (display (apply string-append (map ->string args)))
  (display "\n"))

(define (lshew . args)
  (display (apply lsshew args)))

(define (lsshew . args)
                                        ;  (string-collapse-spaces
  (string-one-line
   (call-with-output-string
    (lambda (port)
      (map (lambda (j) (pretty-print j port)) args)))))
                                        ;)

(define (proper-list? l)
  (or (eq? l '()) (and (pair? l) (proper-list? (cdr l)))))

(define (make-dict . args)
  (cond
   ((null? args) (make-dict equal?))
   ((eq? (car args) eq?) (make-dict-1 hashq-ref hashq-set!))
   ((eq? (car args) eqv?) (make-dict-1 hashv-ref hashv-set!))
   ((eq? (car args) equal?) (make-dict-1 hash-ref hash-set!))
   (#t (err))))

(define (make-dict-1 reffer setter)
  (let ((hashtable (make-hash-table))
        (missing (cons '() '())))
    (lambda args
      (cond
       ((and (eq? (car args) 'exists)
             (null? (cddr args)))
        (let ((key (cadr args)))
          (not (eq? (reffer hashtable key missing) missing))))
       ((and (eq? (car args) 'get)
             (null? (cddr args)))
        (let ((key (cadr args)))
          (let ((val (reffer hashtable key missing)))
            (if (eq? val missing)
                (err 'no-such-dict-entry)
                val))))
       ((eq? (car args) 'map)
        (hash-map (cadr args) hashtable))
       ((eq? (car args) 'keys)
        (hash-keys hashtable))
       ((eq? (car args) 'values)
        (hash-values hashtable))
       ((eq? (car args) 'kv-pairs)
                                        ;(shew 'urg hashtable)
        (hash-kv-pairs hashtable))
       ((and (eq? (car args) 'put)
             (null? (cdddr args)))
        (let ((key (cadr args))
              (value (caddr args)))
          (setter hashtable key value)))
       ((and (eq? (car args) 'shew))
        (shew hashtable))
       (#t (err "bad dict method" args))))))

(define (make-autoadd-dict generator)
  (make-autoadd-fun-dict (lambda (dummy) (generator))))

(define (make-autoadd-fun-dict f)
  (let ((dict (make-dict)))
    (lambda args
      (cond
       ((and (eq? (car args) 'get)
             (null? (cddr args)))
        (let ((key (cadr args)))
          (if (not (dict 'exists key))
              (dict 'put key (f key)))
          (dict 'get key)))
       (#t (apply dict args))))))

(define (make-dict-list)
  (let ((dict (make-dict)))
    (lambda args
      (cond
       ((and (eq? (car args) 'get)
             (null? (cddr args)))
        (let ((key (cadr args)))
          (if (dict 'exists key)
              (dict 'get key)
              '())))
       ((and (eq? (car args) 'add)
             (null? (cdddr args)))
        (let ((key (cadr args)) (value (caddr args)))
          (dict 'put key (snoc
                          (if (dict 'exists key)
                              (dict 'get key)
                              '())
                          value))))
       (#t (apply dict args))))))

;; Map each distinct element of input list to an object
;; generated by generator, and then apply this mapping to
;; the whole list.
(define (generator-dict-map lyst generator)
  (let ((dict (make-autoadd-dict generator)))
    (map (dict 'get _) lyst)))

(define (fun-dict-map lyst f)
  (let ((dict (make-autoadd-fun-dict f)))
    (map (dict 'get _) lyst)))

(define (unique lyst)
  (cond
   ((null? lyst) lyst)
   ((member (car lyst) (cdr lyst)) (unique (cdr lyst)))
   (#t (cons (car lyst) (unique (cdr lyst))))))

(define (has-duplicates? lyst)
  (not (eq? (length lyst) (length (unique lyst)))))

(define (any f lyst)
  (if (null? lyst)
      #f
      (or (f (car lyst))
          (any f (cdr lyst)))))

(define (all f  lyst)
  (if (null? lyst)
      #t
      (and (f (car lyst))
           (all f (cdr lyst)))))

(define-macro (assert exp . stuff)
  `(if ,exp
       '()
       (err "Assertion failure" ',exp ,@stuff)))

(define (id x) x)

(define (err . args)
  (display "Error!\n")
  (shew (map show-shorten args))
  (exit))

(define show-shorten-length 5)
(define (show-shorten-list lyst) (show-shorten-list1 lyst 0))
(define (show-shorten-list1 lyst acc)
  (cond
   ((not (pair? lyst)) lyst)
   ((>= acc show-shorten-length) '(...))
   (#t (cons (car lyst) (show-shorten-list1 (cdr lyst) (+ acc 1))))))

(define (show-shorten o)
  (if (pair? o)
      (map-improper show-shorten-list (show-shorten-list o))
      o))

(define (map-improper f s)
  (if (pair? s)
      (cons (f (car s))
            (map-em f (cdr s)))
      (f s)))
(define map-em map-improper)

(define (sr . es)
  (apply shew es)
  (last es))

(define (last l)
  (if (pair? l)
      (if (null? (cdr l))
          (car l)
          (last (cdr l)))
      (err)))

(define (make-string-string n s)
  (if (<= n 0)
      ""
      (concat s (make-string-string (1- n) s))))

(define (string-one-line s)
  (string-map
   (lambda (c) (if (eq? c #\newline) #\space c))
   s))

(define impl-tracefun-indentation 0)

(define (tracefun-hookist name f)
  (lambda args
    (display "        ")
    (display (make-string-string impl-tracefun-indentation "| "))
    (display "+ ")
    (lshew (cons name args))
    (display "\n")
    (flush-output)
    (set! impl-tracefun-indentation (+ impl-tracefun-indentation 1))
    (let ((result (apply f args)))
      (flush-output)
      (set! impl-tracefun-indentation (- impl-tracefun-indentation 1))
      (display "        ")
      (display (make-string-string impl-tracefun-indentation "| "))
      (display "-> ")
      (lshew result)
      (display "\n")
      (flush-output)
      result)))

(define-macro (tracefun . funs)
  (cons 'begin
        (map (lambda (f)
               `(set! ,f (tracefun-hookist ',f ,f)))
             funs)))

(define (find-first pred lyst)
  (cond
   ((null? lyst) (err pred))
   ((pred (car lyst)) (car lyst))
   (#t (find-first pred (cdr lyst)))))

(define (cton? o)
  (and (pair? o) (ctor? (car o))))

(define (ctor? o)
  (if (symbol? o)
      (let ((c (string-ref (symbol->string o) 0)))
        (and (char>=? c #\A)
             (char<=? c #\Z)))
      #f))

(define (member-deep a lyst)
  (cond
   ((pair? lyst)
    (or (member-deep a (car lyst))
        (member-deep a (cdr lyst))))
   ((eq? a lyst) #t)
   (#t #f)))

;; lens is a -> (extracted . re-inserter)
(define (compose-lens-and-fun lens f)
  (lambda (x)
    (let* ((blah (lens x))
           (extracted (car blah))
           (re-inserter (cdr blah)))
      (re-inserter (f extracted)))))

(define (apply-through-lens lens f o)
  ((compose-lens-and-fun lens f) o))

(define (compose-lenses a b)
  (lambda (x)
    (let* ((blah-b (b x))
           (extracted-b (car blah-b))
           (re-inserter-b (cdr blah-b))
           (blah-a (a extracted-b))
           (extracted-a (car blah-a))
           (re-inserter-a (cdr blah-a)))
      (cons extracted-a (lambda (x) (re-inserter-b (re-inserter-a x)))))))

(define (car-lens x)
  (cons (car x) (lambda (a) (cons a (cdr x)))))

(define (cdr-lens x)
  (cons (cdr x) (lambda (d) (cons (car x) d))))

(define cadr-lens (compose-lenses car-lens cdr-lens))

(define (lensmap lens f l)
  (map (lambda (e) (apply-through-lens lens f e)) l))

(define (fnot f) (lambda (x) (not (f x))))

(define (map-append f . lysts)
  (apply append (apply map (cons f lysts))))

(define (grep pred lyst)
  (map-append
   (lambda (o)
     (if (pred o)
         (list o)
            '()))
   lyst))

(define (divide-by-pred p lyst)
  (cons (grep p lyst) (grep (fnot p) lyst)))

(define (group-by f lyst)
  (if (null? lyst)
      '()
      (let* ((group-of-car (f (car lyst)))
             (divided (divide-by-pred
                       (lambda (x) (eq? group-of-car (f x)))
                       lyst))
             (in-group (car divided))
             (not-in-group (cdr divided)))
        (cons (cons group-of-car in-group)
              (group-by f not-in-group)))))

;; ;; maybe stuff.

;; ;; f should return either (value) or #f; find-first-maybe will return
;; ;; the first one it finds that's not null, in the same format: (value)
;; ;; or #f.
;; (define (find-first-maybe f lyst)
;;   (if (null? lyst)
;;       #f
;;       (let ((r (f lyst)))
;;         (if (null? r)
;;             (find-first-maybe f (cdr lyst))
;;             r))))

;; ;; If any sub-call returns #f, return #f.  Otherwise, extract the
;; ;; value from each singlet and return the list of them.  If you get an
;; ;; #f, don't bother doing the rest.
;; (define (maybe-map f lyst)
;;   (if (null? lyst)
;;       '()
;;       (let ((v (f (car lyst))))
;;         (if (eq? #f v)
;;             #f
;;             (let ((rest (maybe-map f (cdr lyst))))
;;               (if (eq? #f rest)
;;                   #f
;;                   (cons v rest)))))))

;; (define (maybe-map-append f lyst)
;;   (let ((r (maybe-map f lyst)))
;;     (if (eq? #f r)
;;         #f
;;         (apply append r))))

(define (zip f . lysts)
  ;(shew 'um-zip lysts)
  (if (any null? lysts)
      (if (not (all null? lysts))
          (err 'uneven-zip-params lysts (map null? lysts))
          '())
      (cons (apply f (map car lysts))
            (apply zip (cons f (map cdr lysts))))))

;; maybe stuff, for real

(define (just a) (list 'just a))
(define fail 'fail)

(define (fail? a) (eq? a fail))
(define (just? a) (and (pair a) (eq? (car a) 'just) (null? (cddr a))))
(define just-value cadr)

(define (maybe-combine combiner args)
  (if (any fail? args)
      fail
      (begin
        ;(shew 'combine combiner args (map just-value args) (apply combiner (map just-value args)))
        (apply combiner (map just-value args)))))

(define (maybe-append . things)
  (maybe-combine append things))

(define (maybe-list . things)
  (maybe-combine list things))

;; f should return (successful-value) or #f for failure.
;; Returns #f if no success.
(define (first-success f lyst)
  (if (null? lyst)
      fail
      (let ((v (f (car lyst))))
        (if (fail? v)
            (first-success f (cdr lyst))
            v))))

(define (++ . stuff)
  (apply concat (map (lambda (o) (->string o)) stuff)))

(define (->int o)
  (cond
   ((number? o) (inexact->exact (floor o)))
   ((string? o) (->int (string->number o)))
   (#f (err))))

(define (->string o)
  (cond
   ((symbol? o) (symbol->string o))
   ((string? o) o)
   ((number? o) (number->string o))
   ((char? o) (make-string 1 o))
   (#t (sdisplay o))))

(define member? member)
